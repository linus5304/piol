# Backend Agent Instructions — Convex

> For AI agents and developers working on `packages/convex`

## Architecture Overview

```
packages/convex/
├── _generated/          # Auto-generated by Convex (DO NOT EDIT)
├── actions/             # External API calls (payments, webhooks)
│   ├── mtnMomo.ts
│   ├── orangeMoney.ts
│   └── payments.ts
├── seed/                # Database seeding scripts
├── schema.ts            # Single source of truth for data model
├── auth.config.ts       # Clerk authentication config
├── convex.config.ts     # Convex project config
├── http.ts              # HTTP endpoints (webhooks)
├── files.ts             # File upload/storage operations
├── *.ts                 # Domain modules (properties, users, messages, etc.)
└── vitest.config.ts     # Test configuration
```

## Core Principles

### 1. Schema-First Development

Always start from `schema.ts`. Every table must have:
- Clear field definitions with `v.*` validators
- Appropriate indexes for ALL query patterns
- No table scans — if you query by a field, index it

```typescript
// ✅ Good: Index defined for query pattern
properties: defineTable({...})
  .index('by_city_status', ['city', 'status'])

// In query:
ctx.db.query('properties')
  .withIndex('by_city_status', q => q.eq('city', args.city).eq('status', 'active'))

// ❌ Bad: Filtering without index (causes table scan)
ctx.db.query('properties')
  .filter(q => q.eq(q.field('city'), args.city))
```

### 2. Query vs Mutation vs Action

| Type | Use For | Side Effects | Can Call External APIs |
|------|---------|--------------|------------------------|
| `query` | Read operations | ❌ None | ❌ No |
| `mutation` | Write to DB | ✅ DB writes | ❌ No |
| `action` | External calls | ✅ Via mutations | ✅ Yes |

```typescript
// Query: Pure read, automatically cached and reactive
export const getProperty = query({
  args: { propertyId: v.id('properties') },
  handler: async (ctx, args) => {
    return await ctx.db.get(args.propertyId);
  },
});

// Mutation: DB writes, transactional
export const createProperty = mutation({
  args: { title: v.string(), city: v.string() },
  handler: async (ctx, args) => {
    const identity = await ctx.auth.getUserIdentity();
    if (!identity) throw new Error('Not authenticated');
    // ... validation and insert
  },
});

// Action: External API calls (payments, emails)
export const processPayment = action({
  args: { transactionId: v.id('transactions'), amount: v.number() },
  handler: async (ctx, args) => {
    // Can call external APIs
    const result = await fetch('https://api.mtn.com/...');
    // Update DB via mutation
    await ctx.runMutation(internal.transactions.updateStatus, {...});
  },
});
```

### 3. Authentication Pattern

Every authenticated endpoint MUST:
1. Get identity from `ctx.auth`
2. Lookup user in DB by `clerkId`
3. Verify role if needed

```typescript
export const someProtectedMutation = mutation({
  args: { ... },
  handler: async (ctx, args) => {
    // Step 1: Get Clerk identity
    const identity = await ctx.auth.getUserIdentity();
    if (!identity) {
      throw new Error('Not authenticated');
    }

    // Step 2: Get our user record
    const user = await ctx.db
      .query('users')
      .withIndex('by_clerk_id', q => q.eq('clerkId', identity.subject))
      .unique();

    if (!user) {
      throw new Error('User not found');
    }

    // Step 3: Check role (if needed)
    if (user.role !== 'landlord' && user.role !== 'admin') {
      throw new Error('Only landlords can perform this action');
    }

    // ... proceed with operation
  },
});
```

### 4. Authorization Matrix

| Operation | Renter | Landlord | Verifier | Admin |
|-----------|--------|----------|----------|-------|
| View active properties | ✅ | ✅ | ✅ | ✅ |
| Create property | ❌ | ✅ | ❌ | ✅ |
| Edit own property | ❌ | ✅ | ❌ | ✅ |
| Edit any property | ❌ | ❌ | ❌ | ✅ |
| Verify property | ❌ | ❌ | ✅ | ✅ |
| Send message | ✅ | ✅ | ✅ | ✅ |
| View all users | ❌ | ❌ | ❌ | ✅ |
| Change user role | ❌ | ❌ | ❌ | ✅ |

## Domain Modules

### Properties (`properties.ts`)

**State Machine:**
```
draft → pending_verification → verified → active → rented
                                    ↓          ↓
                                 rejected   archived
```

**Key Queries:**
- `listProperties`: Paginated, filtered list (city, price, type, amenities)
- `searchProperties`: Full-text search via search index
- `getProperty`: Single property with landlord info and reviews
- `getMyProperties`: Landlord's own listings

**Key Mutations:**
- `createProperty`: Create draft listing
- `updateProperty`: Edit listing (owner or admin only)
- `submitForVerification`: Move to pending
- `updatePropertyStatus`: Admin/verifier status changes
- `addPropertyImages`: Upload images to listing

### Users (`users.ts`)

**Internal Mutations (Clerk webhook):**
- `createUserFromClerk`: Called when user signs up
- `updateUserFromClerk`: Called when user updates profile in Clerk
- `deleteUserByClerkId`: Soft delete (sets `isActive: false`)

**Public Queries:**
- `getCurrentUser`: Get authenticated user's full profile
- `getUserById`: Get public profile info (excludes sensitive data)

**Mutations:**
- `ensureCurrentUser`: Fallback if webhook race condition
- `updateProfile`: Update own profile
- `completeOnboarding`: Set role and preferences

### Messages (`messages.ts`)

**Conversation ID Format:**
```
{userId1}_{userId2}              // General conversation
{userId1}_{userId2}_{propertyId} // Property-specific conversation
```
User IDs are sorted for consistency.

**Key Patterns:**
- Always verify user is participant before returning messages
- Create notification on new message
- Batch mark-as-read operations

### Transactions (`transactions.ts`)

**State Machine:**
```
pending → processing → completed
              ↓            ↓
           failed      refunded
```

**Escrow States:**
```
held → released
  ↓
refunded
```

**Payment Flow:**
1. Create transaction (pending)
2. Call payment action (processing)
3. Payment provider callback → update status
4. On success: hold in escrow
5. On release: disburse to landlord minus commission

### Payments (`actions/payments.ts`)

**MTN MoMo Flow:**
```
1. processPayment(mtn_momo) → requestPayment → USSD prompt to user's phone
2. User confirms on phone
3. Callback webhook → updateTransactionStatus
4. releaseEscrow → disburseFunds to landlord
```

**Orange Money Flow:**
```
1. processPayment(orange_money) → initializeWebPayment → redirect URL
2. User redirected to Orange Money web page
3. User pays → callback webhook
4. releaseEscrow → disburseFunds
```

## Validation Patterns

### Input Validation

Always use Convex validators. Combine with business logic validation:

```typescript
export const createProperty = mutation({
  args: {
    title: v.string(),
    rentAmount: v.number(),
    city: v.string(),
    propertyType: v.union(
      v.literal('studio'),
      v.literal('1br'),
      // ...
    ),
  },
  handler: async (ctx, args) => {
    // Business validation
    if (args.title.length < 10) {
      throw new Error('Title must be at least 10 characters');
    }
    if (args.rentAmount < 10000) {
      throw new Error('Minimum rent is 10,000 XAF');
    }
    // ...
  },
});
```

### Error Handling

Throw typed errors with user-safe messages:

```typescript
// ✅ Good: Clear, actionable error
throw new Error('Property not found');
throw new Error('Only landlords can create listings');
throw new Error('Payment failed: insufficient funds');

// ❌ Bad: Exposes internals or vague
throw new Error('DB error: connection timeout');
throw new Error('Error');
throw error; // Re-throwing raw error
```

## Performance Guidelines

### Pagination

Always paginate list queries:

```typescript
export const listProperties = query({
  args: {
    limit: v.optional(v.number()),
    cursor: v.optional(v.string()),
  },
  handler: async (ctx, args) => {
    const limit = Math.min(args.limit ?? 20, 100); // Cap at 100
    // ... fetch and paginate
    return {
      items: paginatedItems,
      nextCursor: hasMore ? String(nextIndex) : null,
    };
  },
});
```

### Avoid N+1

Batch related data fetches:

```typescript
// ✅ Good: Single query for all landlords
const properties = await ctx.db.query('properties')...
const landlordIds = [...new Set(properties.map(p => p.landlordId))];
const landlords = await Promise.all(landlordIds.map(id => ctx.db.get(id)));
const landlordMap = new Map(landlords.map(l => [l._id, l]));

// Map back
const result = properties.map(p => ({
  ...p,
  landlord: landlordMap.get(p.landlordId),
}));

// ❌ Bad: N+1 queries
const result = await Promise.all(
  properties.map(async (p) => ({
    ...p,
    landlord: await ctx.db.get(p.landlordId), // Query per property!
  }))
);
```

### Search Index

Use the search index for text search:

```typescript
// In schema.ts
properties: defineTable({...})
  .searchIndex('search_properties', {
    searchField: 'searchText',
    filterFields: ['city', 'status', 'propertyType'],
  })

// In query
const results = await ctx.db
  .query('properties')
  .withSearchIndex('search_properties', q => 
    q.search('searchText', args.query)
     .eq('status', 'active')
  )
  .take(20);
```

## Testing

Use `convex-test` for unit tests:

```typescript
import { convexTest } from 'convex-test';
import { expect, test } from 'vitest';
import { api } from './_generated/api';
import schema from './schema';

test('createProperty requires authentication', async () => {
  const t = convexTest(schema);
  
  await expect(
    t.mutation(api.properties.createProperty, {
      title: 'Test Property',
      city: 'Douala',
      // ...
    })
  ).rejects.toThrow('Not authenticated');
});

test('createProperty creates property for landlord', async () => {
  const t = convexTest(schema);
  
  // Setup: Create user as landlord
  const userId = await t.run(async (ctx) => {
    return await ctx.db.insert('users', {
      clerkId: 'test-clerk-id',
      email: 'test@example.com',
      role: 'landlord',
      // ...
    });
  });
  
  // Act with auth
  const propertyId = await t.mutation(
    api.properties.createProperty,
    { title: 'Test', city: 'Douala', ... },
    { identity: { subject: 'test-clerk-id' } }
  );
  
  // Assert
  const property = await t.run(async (ctx) => ctx.db.get(propertyId));
  expect(property?.title).toBe('Test');
  expect(property?.landlordId).toBe(userId);
});
```

## Webhook Security

Always verify webhook signatures:

```typescript
// http.ts
export default httpRouter({
  '/webhooks/clerk': httpAction(async (ctx, request) => {
    const signature = request.headers.get('svix-signature');
    const timestamp = request.headers.get('svix-timestamp');
    const svixId = request.headers.get('svix-id');
    
    // Verify signature using Clerk's webhook secret
    const isValid = verifyClerkWebhook(
      await request.text(),
      { signature, timestamp, svixId },
      process.env.CLERK_WEBHOOK_SECRET
    );
    
    if (!isValid) {
      return new Response('Invalid signature', { status: 401 });
    }
    
    // Process webhook...
  }),
});
```

## Checklist for New Endpoints

- [ ] Input validation with `v.*` validators
- [ ] Authentication check (`ctx.auth.getUserIdentity()`)
- [ ] User lookup and existence check
- [ ] Role/authorization check
- [ ] Appropriate indexes exist for queries
- [ ] Pagination for list endpoints
- [ ] Error messages are user-safe
- [ ] No PII in logs
- [ ] Tests for happy path and error cases
